## Episode - 1 & 2

React alone dosen't make our app fast (its a small piece of javascript code), there are lot of other things (packages) that comes with create-react-app that bundles, minifies, compresses, git init, caches, optimizes images, code splits etc.. and makes the app fast and production ready

To configure the remote git repository (which is created on github by clicking create new repository) to our project, follow below steps
git init - To convert our local code into a git repository
git branch -M main - By default main branch is "master". So to make the main branch as "main" use this command
Create readme file (README.md) if you dint add it while create git repository on github
Now commit and push your local code in your local git repository to the remote git repository. But your local git does not know what is remote repository. So use below command (you can copy this command from your remote git repository steps, it will be mentioned there clearly)
git remote add origin git@github.com:sakethkota731/namaste-react.git
Now push the code to git using below commands
git add .
git commit -m "episode-01"
git push origin main
(origin means to the remote repository, it means push to the remote repository main branch)

npm init - (It brings npm into our code, so package.json file will be created with this command)

Versions
2.8.3 - in this 2 is major version, 8 in minor versin, 3 is patch version.
If there is any patch/bug fix which dosent require developers to change code we upgrade patch version.
If there is any new functional or minor changes like that which dosent require developers to change code we upgrade minor version.
If there is any existing functional changes or major changes like that which requires developers to change code we upgrade major version.
^2.8.3 - this means it is not fixed and if there is minor changes (upto minor version changes) our version can get updated in package.json. If there is any change till 2.9.9 it will get upgraded automatically to that version (to the latest upto limit) after npm i
~2.8.3 - this means it is not fixed and if there is patch fix (upto patch version changes) our version can get updated in package.json. If there is any change till 2.8.9 it will get upgraded automatically to that version (to the latest upto limit) after npm i
2.8.3 - this means 2.8.3 always and no upgrades

After running - npm init (it will ask couple of question like, package name, description etc), a package.json file will be created with the details that we have given in a JSON format

Package.json is just a configuration for the npm (npm manages the dependecies (packages) of our project, like it stores the version number etc..)

1st main important package is bundler. There are various bundlers in market like webpack, veet, parcel etc.. All bundlers does the same thing (i.e bundles the app and make the app ready for production), only the algorithm that it uses behind differs

Parcel is a dev dependency (i.e bundling, minification, chunking and all are done at lcoal dev environment and not in production)

package-lock.json stores the exact version of installed package (i.e locks the version), whereas package.json store the approximate version of the package.

package-lock.json maintains the package names, its exact version and the versions of all its depedencies which are there inside the node_modules. That's why it is huge

We should not push node_modules in git (include it in .gitignore file), but package.json and package-loack.json should be pushed to github or git repository. Because you can regenerate node_modules on the server

integrety prop in every package object in package-lock.json stores the hash value which keeps track of version and makes sure that the version which is in local is the exact version which is deployed to prod

IGNITE THE APP

Bundlers - Parcel, Webpack, Veet etc..

npm i parcel

npx parcel index.html - Our app will be hosted on to "http://localhost:1234" port. That is parcel created a local server for us (hosted onto a server) and given us a port (1234). That means, Parcel creates a development build from the source index.html and hosts that dev build into the "http://localhost:1234" server.
(Note: npm is to install a package, whereas npx is to execute a package)

Using CDN to get react is a costly operation as it will make a network call to the CDN server to get react. If react is inside our node_modules, it would be easy to use it in our code.
Another disadvantage of using CDN is, lets say we used this CDN - https://unpkg.com/react@18/umd/react.development.js, in future if the react version changed to 19, to use that we have to change the URL again. So it would be easy for us to have react as a dependency and manage it in package.json

npm i react
npm i react-dom

Remove CDNs

import React from "react"
import ReactDOM from "react-dom"

If you run the server you will get an error that says - "Browser scripts cannot have imports or exports". This is because javascript does not recognize import. Browser considers this - <script src="./App.js"></script> as a normal javascript file.
Now we need to tell the browser that it's not a normal javascript file, it is a module by adding type="module" to the script tag - <script type="module" src="./App.js"></script>

Parcel does HMR (Hot module replacement) by using a File watching algorithm which is written in C++ (With this upon saving the file, browser will refresh automatically and new changes can be seen on the page). That is, as soon as you save, it will build the app once again.
Everytime you save, the build time reduces as the parcel is doing caching. It stores the cache in the .parcel-cache folder which is created when we installed and executed parcel (i.e after our first build)

# Parcel

    - Creates Dev build
    - Creates local server
    - HMR = Hot module replacement
    - File watching algorithm (written in C++)
    - Caching - Faster builds
    - Image Optimization
    - Minification (replaces large names with small names etc.. for production builds)
    - Bundling
    - Compressing (i.e reduces the size and ships to production)
    - Consistent Hashing (Outup dosen't change if the names dont change, so consistent hashing is helpful in that case)
    - Code Splitting
    - Diiferential Bundling (supports older browsers i.e different bundles for different browsers)
    - Diagnostic (Proper error messages on console with links that redirects to the code)
    - Error Handling
    - HTTPs
    - Tree Shaking (Our project can have 100 functions, so parcel does tree shaking and removes unused functions and unused code)
    - Different dev and prod bundles/builds (because prod build takes times as it has extra minifications compared to dev build )

    npx parcel index.html - dev build
    npx parcel build index.html - prod build
    But we will get an error if we run this because in package.json we have a property - main: "App.js". This is a conflict as npm sees App.js as entry point but in the  "npx parcel build index.html" command we are giving index.html as entry point, so it gives error. Remove that main: "App.js" property from package.json, you will not get any error

    Upon running "npx parcel index.html" or "npx parcel build index.html" it creates dist folder and minifies/bundles files and puts them inside the dist folder. Whatever UI you see on the browser is coming from the files inside the dist folder, not from the actual files. Whenever we save, dist folder interacts with the .parcel-cache folder to see the recent changes and generate the new build in even lesser time and store new changes in the dist folder which will be reflected in the UI

    By running "npx parcel build index.html", it will create 3 files in the dist folder (other 2 files are mapper files). These 3 files are the production ready code of our app.
    a. 1 HTML file  (index.html) - i.e Minified, Compressed and Combined all the html files into one
    b. 1 CSS file (index.2342dsfsd.css) - i.e Minified, Compressed and Combined all the css files into one
    c. 1 JS file (index.fsedf2132) - i.e Minified, Compressed and Combined all the js files into one

    You shouldn't push "dist" and  ".parcel-cache" folders in github as they can be regenerated on the server by running the command "npx parcel index.html",  like "node_modules". So put them in .gitignore

    (LOCAL FE CODE) ---pushed to git-----> (GIT) <-----fetches from git and runs the npx parcel index.html that creates all dist and other folders--- (SERVER)

    browserslist - this package comes with parcel. With the help of this package you can make your app work with different browsers and also older versions of browser. For this to work, you need to mention it in the package.json file like below
    "browserslist": [
        "last 2 versions",
        // "last 2 chrome versions"
    ]

## Episode - 3

You can add script tags in package.json as a shortcut to excecute npm packages.
Example: If you write this script tag - "start": "parcel index.html", you can exceute or start the parcel/server by running just - "npm run start" command instead of running "npx parcel index.html".
You can run "npm start" instead of "npm run start" as both are same because start is a reserved keyword on npm, But you can't do this with "npm run build".

React - It will have core features of react and it can create React elements which is nothing but objects
ReactDOM - It will interact with HTML DOM and will convert React elements to HTML elements and will put it in HTML DOM by replacing (not appending) the children of root element.

JSX - HTML or XML like syntax

JSX and React are seperate. JSX is not a part of React like many think. Creating ReactElements using pure core React is tough so developers have came up with JSX which is similar to HTML.

JS Engine and React can't understand JSX. JSX will be converted to React.createElement by Parcel - babel, which React can understand, and this React.createElement will be again converted to Javascript object that JS Engine can understand. So we can write JSX (HTML like syntax) within Javascript code. That means we can write it together in same file.

babel - Transpiler (Converts JSX syntax to React.createElement that React can understand)

If we have to give attributes in JSX then it should be camelCase - className (instead of class),tabIndex (instead of tabindex),onClick (instead of click)

If you are writing JSX, you need to write in single line like below
const jsxHeading = <h1 id="heading" >Namaste React using JSX ðŸš€</h1>;

If you want to write JSX in multiple lines then you should write like below because JSX needs to understand where it started and where it ended
const jsxHeading = (

  <h1 id="heading" className="head">
    Namaste React using JSX ðŸš€
  </h1>
);

React Components - 1. Class based components 2. Functional Components

If you are creating a functional components then name it with a capital letter first (Ex: HeadingComponent), else you will get an error. It's react way of recognising functional components.

React Functional Component is a normal javascript function that returns some piece of JSX (i.e it returns a ReactElement (as babel converts that JSX to React.createElement)).
NOTE: Functional Component returns only one ReactElement (but it can be nested).

\*\*NOTE: To render a ReactElement to browser you do - "root.render(heading)". But to render React Component onto the browser we do this - "root.render(<HeadingComponent />)"
Similarly if you want to put an element inside a JSX you do like below

 <h1 id="heading" className="head">
    {title}
    Namaste React using JSX ðŸš€
  </h1>
But if you want to put a component inside JSX then you do like below
 <h1 id="heading" className="head">
    <Title />
    <Title></Title>
    {Title()}
    Namaste React using JSX ðŸš€
  </h1>
NOTE: Babel is converting all the above JSX into ReactElement which is nothing but a javascript object

If you put curly braces inside JSX - {}, then you can write any piece of javascript inside those curly braces

Cross Site Scripting - Lets say you have called an API which gives Malicious data (which is rare) and include that in your JSX like below
const data = api.getData()

 <h1 id="heading" className="head">
    {data}
    Namaste React using JSX ðŸš€
  </h1>
In this case the hacker will get a chance to run any javascript code on your browser (by doing this he can do many things like stealing cookies or localstorage data etc..)
But JSX will handle such things. Whenever we get such malicious data and include it inside curly brackets - {}, then JSX will first sanitise the data and then only it shows in the browser. This will protect our App from Cross Site Scriptings.

NOTE: React is readable not because of React, but it's because of JSX which is making it much more readable than React and this JSX is independent from React.

## Episode - 4

Prop - Passing a prop to a component is just like passing an argument to a function. Whatever props we pass to a component, react will wrap all those props into an object and will pass that object to that component. If you want to pass data dynamically to a component, you can pass it as props

Config Driver UI - Our UI is derieved by config (which we get from API response). For example - In swiggy app you may have different offers in different sate, for that you cant build different UIs for each state. So based on the configs (state property) you get from backend backend you show different offers for different state (based on location selected). Config is the data coming from the API, which keeps on changing based on different factors like user, location etc.

Cloudinary - It is a CDN where we can store all our app related images

Add a unique key (key={id}) to each loop item in react - Reason for this is, it helps react optimize the render cycle. Lets say we have 1000 loop items (component) and a new 2 cards came in, 1 at first place and other somewhere in between. Now react will not know where exactly to place that cards. So it will re-render the whole 1002 items again which is time consuming (especially when it is an infinite scroll). So the best practice is to add a unique key (key={id}) for each loop item so that react will be able to identify where exactly to place those 2 new items instead of re-rendering the whole list of items again, which will be a huge code optimization. If we don't give a unique key for each item in a loop, then react will give a warning in the console.
Note: Here item means a component/element

React does not recommend to use indexes as unique key - Because this may cause a negative impact if the order of the list of items changes. If you don't have a unique id, as backend to send it else in the worst case you can use index which is still better than not passing any key.

Optional Chaining - a?.b?.c => If the object or the function is not available, then it will return undefined, instead of throwing an error.

While using React, developers don't need to bother on how to update the actual DOM like how we do with jQuery by parsing the DOM to find the element that needs to be updated. In react you just need to focus on how the current state of the UI is at different intervels and need to update the state that's it. Rest is taken care by React and ReactDOM to create a virtual DOM and compare it with actual DOM and update only those node on the actual DOM which are change, instead of re-rendering the whole DOM tree (which is actually done on page refresh).

Virtual DOM - It is like a copy of an actual DOM, which is created by ReactDOM based on the JSX we returned and renders this virtual DOM to actual DOM with the help of root.render() method.

Reconciliation - Virtual DOM is not rendered directly to browser application. React uses reconciliation, which is a diffing algorithm to compare both vitual DOM and real DOM, and find out what exactly changed and only modify that instead of rerendering entire DOM.
There are 3 scnarios:

1. If component types are different like - <a><p>Text</p></a> and <b><p>Text</p></b> then that entire tree node is replaced (rerendered) with new node.
2. If component types are same and attributes are different - <div className="abc"></div> <div className="xyz"></div> the entire node no need to be rerendered. Only that specific attribute will be modified/replaced.
3. If there are list of elements on same level and new element gets added to that list at end, then reconciliation algorithm will compare each list item from start and adds last item at end. Now if an element get added at beginning, then when ReactDOM starts diffing from first element, it finds first elements from both trees different and will rerender all the list which is wrong. So we need to provide unique key to each item in a list to avoid this problem

## BEST PRACTICES

Config driven UI
Passing unique key for each item (component) inside a loop

What is Virtual DOM? - https://reactjs.org/docs/faq-internals.html
What is Reconciliation in React? - https://reactjs.org/docs/reconciliation.html
What is React Fiber? - https://github.com/acdlite/react-fiber-architecture
Why we need keys in React? When do we need keys in React?
Can we use index as keys in React? - https://robinpokorny.com/blog/index-as-a-key-is-an-anti-pattern/

## Episode - 5

Default export - export default Component => import Component from "../src/Component" (Used when there is a single component in a file)
Named export - export const Component => import { Component } from "../src/Component" (Used when there are multiple components in a file)
You can use Default export and Named export together. But only thing is you cannot use default export more than once in a file.

When we change the data, our UI should automatically change based on that. Like lets say we have an restaurantArray (let restaurantArray = [{name:"R1"}]), and if we try to manypulate this array on a click event in react, our UI Restaurant Cards will not get updated, but the data will get changed which you can see it on console log. This is where React will help us by providing useState hook. (That is intead of using normal javascript variable you need to use react state variable, which defines the state of the component or app).
React/Angular/Vue all these frameworks primary goal is to keep the data layer in sync with the UI layer (Data Layer | UI Layer), that is by doing DOM manipulations. Fastness of these frameworks will depend on how efficiently they are manipulating/changing the DOM on the data change. That is why React is much faster as it using Virtual DOM, Diffing alogorithm, Reconciliation etc.. for faster DOM manipulations

## React Hooks

It is just a normal javascript function which comes with special abilities (we can say them as utility functions) that react provides us. React will do named export of these hooks so that we can import them like this - import {useState} from 'react'. But it will default export React -
import React, {useState} from 'react'

useState - Super powerful variable (state variable). Whenever a state variable updates, React re-renders the component

(Note: Why React is fast? - Because React is doing efficient DOM manipulation. Not because it bundles, minifies etc.. which are done by other packages like webpack, parcel etc and not by React. React is fast because it does the DOM manipulations much faster compared to other libraries in much lesser and efficient code behind the scenes. This is the core logic of React. That is why React is the best programming language)

Check Reconciliation.jpg file under static folder

## Episode - 6

There are 2 ways to fetch data

1. App Loads -> API (500ms) -> Render
2. App Loads -> Render (Basic skeleton UI) -> API (to fetch data) -> ReRender => [This approach we follow in react].

# useEffect

useEffect is also just a javascript function which comes with some super powers. We pass 2 arguments (callback function and dependency array) to useEffect

useEffect(()=>{
console.log("useEffect called");
},[])

This above useEffect callback function will be called after the component renders (That is after component mounted => componentDidMount). So we write code to fetch data inside this callback function so that it executes and fetches the data after the component renders.

Now lets say you did console log at 3 places :

1. Inside Body component and outside return block
2. Inside return block
3. Inside useEffect's call back function

Now all console logs will be printed in the above order only becauese when Body component is called, it executes line by line like a Javascript function and after executing the first console log outside return block, it then executes return block console log and then executes call back funtion's console log

When you try to fetch swiggy API from your local origin it throws error saying - "Access to fetch at 'https://www.swiggy.com/dapi/..' from origin 'http://localhost:1234' has been blocked by CORS policy. No 'Access-Control-Allow-Origin' header present on the requested header". This error is throw by the browser, that is browser is blocking to access data from different origin. To overcome this you need to add CORD chrome extension.

\*\*\*Note: When you update a state variable in React, the current component containing the state variable will be called again, that means, that function will get executed again line by line (You can see this by doing console log inside that component. Whenever state updates, the console log gets printed again) and it will create a new Virtual DOM. Inshort whenever a react state variable updates, react triggers the reconciliation algorithm, which executes the current component(function) again and generates a new Virtual DOM and compares it with old Virtual DOM and then updates the real actual DOM with only the differences found on comparision from old Virtual DOM.
Also, you may have a doubt like how a const state variable can get updated as its a constant. But here, whenever state updates the component gets re-rendered with a new state value, that is a new instance, which is not the same previous const variable. When the enire funtion gets executed, it builts a new Virtual DOM tree and then compares it with the previous tree and finds the difference betweeen two and then updates the real DOM with only the diff found.

\*\*\*Note: When you are using input text box and tried to make it a controlled component by using local variable instead of local state then the UI wont get updated as on every onChange you will be updating local variable (value) which can be printed in console but it wont be reflected in actual DOM
(let value = ""; <input value="" onChange={(e)=>{value = value+e.target.value}} value={value}/>) as the actual DOM is not getting re-rendered as we are not using and updating the local state variable

CORS - Cross Origin Resource Sharing is a browser security mechanism. When we request or post data from a different origin, browser throws this error. To overcome this server needs to set our request origin in Access-Control_allow-Origin headers. If its public it will be \*. When we request/post data from different origin. first preflight/options call will be made, whick server validates and sends back additional hhtp headers to browser, by which browser will know its safe call and is allowed, then only actual call get/post/.. is made.

JS expression - Something which resolves to a value like, const a = 5; or const b = getValue(); Here both 5 and getValue() are expressions
JS statement - Statements are something which dosent resolve to a value and perform some actions like, if statement, while, for, const a = 5. All these are statements. You cannot keep a statement in place of expression like, console.log(const a); This will throw error.

## Episode - 7

useEffect - useEffect callback function is called after every render (also re-render) of that component. But the Dependency Array changes the behaviour or decides when that callback function should be called (that means on which state changes).

\*\*\*Note: If there is no dependency array, then the useEffect (callback function) will get called on every render (also re-render)
If the dependency array is empty ([]), then the useEffect (callback function) will get called on only the initial render (just once).
If we give something inside the dependency array [state] then useEffect (callback function) will get called only when that dependency(state) changes.

## react-router-dom

createBrowserRouter - This helps to create the routing configuration (by passing list of paths as an arguments)
RouterProvider - This helps to provide that routing configuration in our application. It is a Component in which we pass router configuration and this returns the specified component for a particular path
useRouteError - This is a hook given to us by react-router-dom. Using this hook we can get more information about the error.

---

Example:
const appRouter = createBrowserRouter([
{
path: "/",
element: <AppLayout />,
errorElement: <Error />,
},
{
path: "/about",
element: <About />,
},
{
path: "/contact",
element: <Contact />,
},
]);

const root = ReactDOM.createRoot(document.getElementById("root"));

root.render(<RouterProvider router={appRouter} />);

---

Outlet - This is a component given to us by react-router-dom. By using this we can show children of a particular route.

---

Example:
const AppLayout = () => {
return (

<div className="app">
<Header />
<Outlet />
</div>
);
};

const appRouter = createBrowserRouter([
{
path: "/",
element: <AppLayout />,
children: [
{
path: "/",
element: <Body />,
},
{
path: "/about",
element: <About />,
},
{
path: "/contact",
element: <Contact />,
},
],
errorElement: <Error />,
},
]);

const root = ReactDOM.createRoot(document.getElementById("root"));

root.render(<RouterProvider router={appRouter} />);

---

Link - This is a component given to us by react-router-dom. This helps to navigate to other routes without reloading the page unlike anchor tags.
Example : <Link to="/about">About Us</Link>
\*\*\*This is why React applications are single page applications. Even while adding routes it wont refresh the page or go to new page. It just changes or switches to a different component by making our application a single page application.

## There are 2 types of Routing

1. Server Side Routing - Whenever you navigate to a different route, the page refreshes and make the network calls to fetch the HTML pages from the server. Server Side Routing has multiple html pages like Home.html, About.html etc..
2. Client Side Routing - Whenever you navigate to a different route, the page will not refresh and no network call is made to fetch HTML pages. All pages/components are there is the client side itself.
   Single Page Applications uses Client Side Routing. It just manipulates or interchanges between the components and will not make any API calls to fetch new HTML pages. Client Side Routing will only have a single html page.

## Episode - 8

Creating a class based component:

---

import React from "react";

import React from "react";

class UserClass extends React.Component {
constructor(props) {
super(props);
this.state = {
count: 0,
count2: 2,
};
console.log("Child Constructor");
}
render() {
console.log("Child Render");
const { name, location } = this.props;
const { count, count2 } = this.state;
return (

<div className="user-card">
<h1>Count: {count}</h1>
<button
onClick={() => {
this.setState({
count: this.state.count + 1,
count2: this.state.count2 + 1,
});
}} >
Count Increase
</button>
<h1>Count2: {count2}</h1>
<h2>Name: {name}</h2>
<h3>Location: {location}</h3>
<h4>Contact: @sakethkota73</h4>
</div>
);
}
}

export default UserClass;

---

super() functions calls the parent classs constructor and super(props) passes props to parent constructor by invoking this. By doing this we will be able to use all the variables and methods in parent instance, in our local instance only (this).
Even if we use multiple useStates in functional components, behind the scenes react will put all those states in a single big object like we are doing now in class based components

How to update state variables?
Never update state variables directly. React gives you a method called setState to update state variables in class components.
this.setState({
count: this.state.count + 1,
});
This only updates count key in the entire state object and does not change the other states.

In any component first the constructor will be called and the after the render method will be called. If it has a parent then first the parent constructor and rendere method will be called and then after comes the child contructor and render method. Once the component is mounted, the componentDidMount() (same as useEffect with empty dependency array in functional components) method will be called.
\*\*\*But here the catch is, parent componentDidMount will be called after the child componentDidMount because the parent component is fully rendered only after rendering its child component. That means the parent componentDidMount will be called only after the component(including its child component) has been completely mounted onto the webpage.

\*\*\*Note: There are two phases in ReactLifecycle.

1. Render Phase - constuctor() is called, Next render() in called
2. Commit Phase - React updates the DOM and refs, next componentDidMount() is called

**In Mounting Phase** - First there is a render phase and then comes the commit phase. So inside a parent component if we have 2 child components then:

1. Parent constructor is called
2. Parent render is called
3. Child1 constructor is called
4. Child1 render is called
5. Child2 constructor is called
6. Child2 render is called
7. Child1 componentDidMount is called
8. Child2 componentDidMount is called
9. Parent componentDidMount is called

Here we expect Child1 componentDidMount to be called after Child1 render is called. But as there are 2 phases (render phase and commit phase). React first renders (means executes those components and runs reconciliation algorithm) parent component and than all its child components and after finishing renders, it then starts the commit phase where it updates the actual DOM from child to parent and then calls the componentDidMount methods of those two child methods after they are mounted onto the browser and then calls componentDidMount method of the Parent. React does this wat to optimise the number of DOM updates and improve the performance of App. Instead of updating DOM 3 times, it just updated it once after rendering (executing) all components to improve the performance. So here React is batching the render and commit phase of all the child components. React is doing this because DOM manipulation is the most expensive operation and React is trying to optimise by doing this batching mechanism.
Note: Batcing the render phase means - React builds virtual DOM trees (js objects) of all child components and then attaches those trees to the parent virtual DOM tree (js object).
Batcing the commit phase means - React now commits this entire DOM tree (including parent and children) at once onto the browser (that is, by updating the real DOM).
This is why React is fast - First is, instead of changing the entire DOM tree, it just compares it with virtual DOM and sees what has been changed exactly and only does that part of changes to DOM. Second is, instead of manu=ipulating DOM multiple times, React just batches all the commits and does a single commit (real DOM manipulation) to the DOM.

1. constructor()
2. render()
3. componentDidMount()

**In Updating Phase** - In componentDidMount, if we make an API call and then update the state with this.setState() after receiving the data from API, then the UPDATE Lifecycle will get triggered and first the render methid will be called which starts the recociliation algorithm generating the virtual DOM tree and after that, React updates the actual DOM comparing it with virtual DOM and then after that componentDidUpdate() will be called. Note that constructor method will not be called in the update cycle.

1. render()
2. componentDidUpdate()

**In Unmounting Phase** - When the component gets removed from the actual DOM then the componentWillUnmount() method will be called. You use componentWillUnmount() method to clear all the mess (like events, setIntervel, setTimeOut etc..) that you have created which needs to be removed from memory to not impact the App's performance.

1. componentWillUnmount()

**Functional component equivalents**

componentDidMount()

useEffect(()=>{

},[])

---

componentDidUpdate()

useEffect(()=>{

})

---

componentWillUnmount()

useEffect(()=>{
return ()=>{
//Some piece of code
}
},[])

---

componentDidUpdate(prevProps, prevState){
if(this.state.count !== prevState.count || this.state.count2 !== prevState.count2){
//For same action
}
}

useEffect(()=>{
//for same action
},[count,count1])

---

componentDidUpdate(prevProps, prevState){
if(this.state.count !== prevState.count){
//for different actions
}
if(this.state.count2 !== prevState.count2){
//for different actions
}
}

useEffect(()=>{
//for different actions
},[count])

useEffect(()=>{
//for different actions
},[count2])

---

<!--
----MOUNTING-----
Constructor (set state with dummy data)
Render (render with dummy data)
  <Updates the Real DOM with dummy data>
ComponentDidMount
  Make API call
  this.setState


----UPDATING-----
Render (render with API response data)
  <Update the real DOM with API data>
ComponentDidUpdate

----UNMOUNTING-----
componentWillUnmount
 -->

**All React Lifecycle Methods**

1. constructor()
2. render() - Entire Functional component itself
3. componentDidMount() - useEffect(()=>{},[])
4. componentDidUpdate() - useEffect(()=>{})
5. componentWillUnmount() - useEffect(()=>{return ()=>{}},[])

Note: We cannot use async with useEffect callback function
